# 变量、类型与基本运算

Julia 的类型是可选的。换言之，就是用户可以选择是否对函数参数及函数的内部变量显示声明类型。Julia 的类型系统也是其性能的关键所在；深入理解这一点至关重要，因为这有益于使用类型注解（这将对注释及调优，还有执行速度都有帮助）。本章讨论Julia 的基本内置类型及其基本运算，同时也会讨论类型及作用域等概念。

本章包含如下几个方面的内容:

- 变量、命名规则、注释
- 类型
- 整型、浮点型
- 基本数学函数及运算
- 有理数及复数
- 字符、字符串
- 正则表达式
- 数组
- 日期与时间
- 作用域及常量

后续你也将在Julia 的 REPL[^REPL] 中尝试给出的样例代码进行学习。

## 变量、命名规则、注释

数据都是以诸如`1`、`3.14`、`"Julia"` 的值存储的。而每个值都有一个类型。比如3.14 的类型是`Float64`。其他基本类型及例子就如：`Int64` 类型的42，`Bool` 类型的 `true` 和 `false`，还有`Char` 类型的 `'X'`。

与当今其他语言不同，Julia 的单字符跟字符串是不同的。字符串可包含任意数量的字符，并且用双引号引起来；而单引号则仅仅用于字符。变量，就是被赋予一个确切值（数值和字符串）后的该值的一个名称。比如`x = 42`。变量包含该值的类型；这个类型是由`typeof` 这个函数确定的。比如`typeof(x)` 的结果就是`Int64`。

变量的类型是可变的，比如`x = "I am Julia"` ，`typeof(x)` 返回的类型就是 `ASCIIString` 了。Julia 中，不必像C 或 Java 中那样声明变量（以表征其类型），但每一个变量必须被初始化（也就是绑定某个确切的值），如此Julia 便能推断其类型了。

```julia
julia> y = 7
7
julia> typeof(y)
Int64
julia> y + z
ERROR: z not defined
```

上述例子中，z 使用前未被初始化，故而报错。将变量与操作符（比如上例中的`+`）、函数组合使用，就得到表达式了。表达式总会在计算后产生新值。与其他语言不同，Julia 中一切皆是表达式，所以每次都会返回值。这也是使用REPL 中的乐事，因为每一步都能看到结果。

变量类型决定了你能对该变量做哪些操作，也就限制了你对该变量能使用的操作符，从这个意义上讲Julia 就是一种强类型语。言。后面这个例子，x 仍然是`String` 类型，所以不能与还是Int64 类型的y 求和。但一旦我们给x 赋值一个浮点数，那么我们就可以求和了：

```julia
julia> x + y
ERROR: `+` has no method matching +(::ASCIIString, ::Int64)
julia> x = 3.5; x + y
10.5
```
其中，`;` 英文分号表示前面表达式结束并不打印结果。

变量名区分大小写的。一般来说，使用小写字母；长变量名可用下划线连接多个词。变量名首个字符使用字母；然后其余字符就可使用数字及下划线了。当然也可使用Unicode 字符。命名时最好使用明了、言简意赅的名字。如后便是几个规范的变量名：`mass, moon_velocity, current_time, pos3, and ω1`。但是最后两个变量名表意不明，若替换成如后两名更好：`particle_position, particle_ang_velocity`

以井号`#` 开头的每行代码都为注释，如后例子:

```julia
# Calculate the gravitational acceleration grav_acc: 
gc = 6.67e-11 
# gravitational constant in m3/ kg s2
mass_earth = 5.98e24 # in kg 
radius_earth = 6378100 # in m 
grav_acc = gc * mass_earth / radius_earth ^ 2 # 9.8049 m/ s2
```

多行注释在实际中，对于写成多行的说明以及暂时注释多行代码都是有用的。Julia 中使用`#=` `=#` 对包含在其中的多行进行注释。要显示某些值，使用如后的`print` 或 `println` 即可：

```julia
julia> print(x)
3.5
```
若要对输出设置颜色，可用`print_with_color(:red, "I love Julia")`。其中第一个参数就是设置颜色的。

处理复杂类型的变量时，常用到“对象”（抑或“实例”）。但是，实际上对象实施操作时，Julia 使用的是函数式的方式。例如会使用`action(object)` 而非`object.action()`，这与其他面向如Java、C# 这种面向对应的语言很是不同。

REPL 中，在每一行命令没有`;` 作为结束符号的情况下，执行结束后，最后一个表达式的值就会自动显示。而在单独的脚本中，Julia 只会在脚本显式声明打印（亦即使用`print` 和`println`）的时候才会显示内容；若要像REPL 中那样显示一个对象，就需要显示声明`display(object)` 。

## 类型

Julia 类型系统首屈一指。Julia 多数时间像Python 一样是动态类型的。例如一个变量先前是赋值整型，后来可以赋值浮点型。如后：

```julia
julia> x = 10
10
julia> x = "hello"
"hello"
```
然而，也可选择把类型定义加到变量声明的地方；如此此变量就只可被重新赋值为同类型的值。譬如，声明`x::ASCIIString` 就是说只能将字符串赋值给x；一般形式就是`var::TypeName`。这种显示声明，通常也被用着限制函数参数的具体类型。并且额外的类型信息，可当作注释，也可让即时编译器产生优化得更好的机器码；并且这样也能让开发环境提供更好的支持，譬如代码工具中也可以检查代码是否存在类型错误。



[^REPL]:  read–eval–print loop 即交互式的终端